# netcode.io 1.0

**netcode.io** is a simple protocol for creating secure client/server connections over UDP.

## Architecture

There are three main components in a netcode.io-based architecture:

1. The web backend
2. Dedicated servers
3. Clients

The web backend is a typical web server, for example nginx, which authenticates clients and provides a REST API. Clients are endpoints running the netcode.io protocol that want to connect to dedicated server instances. Dedicated servers are instances of the server-side portion of the game or application running on top of netcode.io that run in data centers or the cloud.

The sequence of operations for a client connect are:

1. A client authenticates with the web backend
2. The authenticated client requests to play a game
3. A connect token is generated by the web backend and passed to that client over HTTPS
4. The client uses that connect token to establish a connection with a dedicated server over UDP
5. The dedicated server runs logic to ensure that only clients with a valid connect token may connect to it
6. Once connection is established, the client and server exchange encrypted and signed UDP packets.

This protocol is designed with simplicity in mind, and is focused exclusively on the dedicated server use-case. 

Therefore, netcode.io has the following limitations:

1. Dedicated servers are expected to be hosted on a publicly accessible IP address. There is no support for NAT punch-through between clients and servers. 
2. Player hosted servers are not supported because the security model is based around the web backend and dedicated server instances sharing a private key.

## General Conventions

All data in the netcode.io protocol is serialized in a binary format.

Integer values are serialized in little endian byte order.

## Connect Token Structure

A connect token is a short-lived token that transmits the client authentication on the web server to clients connecting to dedicated servers over UDP.

The connect token consists of two parts: private and public.

The private part of the connect token is encrypted and signed with a shared private key known to the web backend and the dedicated server instances. The private portion of the connect token is sent over UDP as part of the connection handshake between a client and server.

Prior to encryption the private connect token has this binary format:

    [client_id] (uint64) // globally unique identifier for an authenticated client
    [num_server_addresses] (uint32) // in [1,32]
    <for each server address>
    {
        [address_type] (uint8) // value of 0 = IPv4 address, 1 = IPv6 address.
        <if IPV4 address>
        {
            // for a given IPv4 address: a.b.c.d:port
            [a] (uint8)
            [b] (uint8)
            [c] (uint8)
            [d] (uint8)
            [port] (uint16)
        }
        <else IPv6 address>
        {
            // for a given IPv6 address: [a:b:c:d:e:f:g:h]:port
            [a] (uint16)
            [b] (uint16)
            [c] (uint16)
            [d] (uint16)
            [e] (uint16)
            [f] (uint16)
            [g] (uint16)
            [h] (uint16)
            [port] (uint16)
        }
    }
    [client to server key] (32 bytes)
    [server to client key] (32 bytes)
    [user data] (256 bytes) // user defined data specific to this protocol id
    <zero pad to 1024 bytes>

The connect token private data is written to a buffer that is 1024 bytes large.

The worst case size is 8 + 4 + 32*(1+8*2+2) + 32 + 32 + 256 = 940 bytes. The rest is zero padded.

Encryption of the connect token private data is performed using libsodium AEAD primitive *crypto_aead_chacha20poly1305_encrypt* using the following binary data as the associated data: 

    [version info] (13 bytes)       // "NETCODE 1.00" ASCII with null terminator.
    [protocol id] (uint64)          // 64 bit value unique to this particular game/application
    [expire timestamp] (uint64)     // 64 bit unix timestamp when this connect token expires

The key for encryption is a 32 byte private key known to both the web backend and the dedicated server instances. 

The nonce for encryption is a 64 bit sequence number that starts at zero and increases with each connect token generated. 

Encryption is performed on the first 1024 - 16 bytes, leaving the last 16 bytes in the 1024 byte buffer to store the HMAC:

    [encrypted private connect token] (1008 bytes)
    [hmac of private connect token] (16 bytes)

The form above is referred to as the _encrypted private connect token data_.

The public portion of the connect token is not encrypted, and exists to provide the client with the information it needs to connect to a dedicated server such as the list of server IP addresses to connect to, and the encryption keys to use for UDP packets. There is some redundancy in this data vs. the private connect token data, because the clien (by design) does not know the shared private key, and cannot decrypt the private connect token data.

Combining the public and private portions together gives us a _connect token_:

    [version info] (13 bytes)       // "NETCODE 1.00" ASCII with null terminator.
    [protocol id] (uint64)          // 64 bit value unique to this particular game/application
    [create timestamp] (uint64)     // 64 bit unix timestamp when this connect token was created
    [expire timestamp] (uint64)     // 64 bit unix timestamp when this connect token expires
    [encrypted private connect token sequence] (uint64)
    [encrypted private connect token data] (1024 bytes)
    [num_server_addresses] (uint32) // in [1,32]
    <for each server address>
    {
        [address_type] (uint8) // value of 0 = IPv4 address, 1 = IPv6 address.
        <if IPV4 address>
        {
            // for a given IPv4 address: a.b.c.d:port
            [a] (uint8)
            [b] (uint8)
            [c] (uint8)
            [d] (uint8)
            [port] (uint16)
        }
        <else IPv6 address>
        {
            // for a given IPv6 address: [a:b:c:d:e:f:g:h]:port
            [a] (uint16)
            [b] (uint16)
            [c] (uint16)
            [d] (uint16)
            [e] (uint16)
            [f] (uint16)
            [g] (uint16)
            [h] (uint16)
            [port] (uint16)
        }
    }
    [client to server key] (32 bytes)
    [server to client key] (32 bytes)
    [timeout seconds] (4 bytes)         // number of seconds with no packets before client conenction times out
    <zero padding to 2048 bytes>

The connect token is written to a buffer that is 2048 bytes large.

The worst case size is 13 + 8 + 8 + 8 + 8 + 1024 + 4 + 32*(1+8*2+2) + 32 + 32 + 4 = 1749 bytes. The rest is zero padded to 2048 bytes.

This is the binary format passed from the web backend to the client when the client wants to connect to a server.

## Packet Structure

## Connect Token

## Challenge Token

## Client State Machine

## Server Connection Processing

