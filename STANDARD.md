# netcode.io 1.0

**netcode.io** is a simple protocol for creating secure client/server connections over UDP.

## Architecture

There are three main components in a netcode.io-based architecture:

1. The web backend
2. Dedicated servers
3. Clients

The web backend is a typical web server, for example nginx, which authenticates clients and provides a REST API. Clients are endpoints running the netcode.io protocol that want to connect to dedicated server instances. Dedicated servers are instances of the server-side portion of the game or application running on top of netcode.io that run in data centers or the cloud.

The sequence of operations for a client connect are:

1. A client authenticates with the web backend
2. The authenticated client requests to play a game
3. A connect token is generated by the web backend and passed to that client over HTTPS
4. The client uses that connect token to establish a connection with a dedicated server over UDP
5. The dedicated server runs logic to ensure that only clients with a valid connect token may connect to it
6. Once connection is established, the client and server exchange encrypted and signed UDP packets.

This protocol is designed with simplicity in mind, and is focused exclusively on the dedicated server use-case. 

Therefore, netcode.io has the following limitations:

1. Dedicated servers are expected to be hosted on a publicly accessible IP address. There is no support for NAT punch-through between clients and servers. 
2. Player hosted servers are not supported because the security model is based around the web backend and dedicated server instances sharing a private key.

## General Conventions

All data in the netcode.io protocol is serialized in a binary format.

Integer values are serialized in little endian byte order.

## Connect Token Structure

A connect token is a short-lived token that transmits the client authentication on the web server to clients connecting to dedicated servers over UDP.

The connect token consists of two parts: public and private.

The private portion of the connect token is encrypted and signed with a shared private key known to the web backend and the dedicated server instances. The private portion of the connect token is sent over UDP as part of the connection handshake between a client and server.

Prior to encryption the private connect token has this format:

    [client_id] (uint64)
    [num_server_addresses] (uint32)
    <for each server address>
    {
        [address_type] (uint8) - 0 = IPV4 address, 1 = IPV6 address.
        <if IPV4>
        {
        }
        <else if IPV6>
        {
        }
    }

When encrypt

The public portion of the connect token is not encrypted, and exists to provide the client with the information it needs to connect to a dedicated server such as the list of server IP addresses to connect to, and the encryption keys to use for UDP packets.

When the private and public portions are combined they form a _connect token_.

The public portion exists

## Packet Structure

## Connect Token

## Challenge Token

## Client State Machine

## Server Connection Processing

