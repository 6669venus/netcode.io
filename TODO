DONE

    Continue processing connection response.

    Server is now sending connection denied back to client, but client is not receiving this. Why not?

    Fixed so connection denied response is processed while in sending connection response state.

    Add data structures to look up client by id, address.

    Port across functions to look up client by id, address.

    Extend the code to ignore connection request / connection response if the client address or id is already connected.

    Work out what the next state is for clients on connection response.

    Does the client get fully connected, with a pending flag, so the client keeps sending the keep-alive until connection is confirmed.

    Or do I extend the server-side to have a state per-slot, eg. 

        CLIENT_SLOT_FREE
        CLIENT_SLOT_PENDING
        CLIENT_SLOT_CONNECTED

    Think over this for a while, because any deviation from how yojimbo does it needs to have a good reason.

    Decided to stick with the state structure from yojimbo. No good reason to deviate. Get it finished!

    Port across function to connect client

    Send a keep alive packet back to the client when the client is connected.

    Make sure the client completes connection to the server.

    Add data structure per-client slot for time last packet sent, time last packet received (for timeouts).

    Clear the last packet send and receive time on connect to the current time.

    Server needs a way to look up encryption index for packets by address.

    This will be used on packet send and packet receive.

    Ideally, each client should cache the encryption index eg. client_encryption_index[NETCODE_MAX_CLIENTS]

    This way it can be quickly looked up for packet sends.

    However, when packets are received the address needs to look up to client index, then client index -> read packet key.

    Also, should probably add checks in timeout check to make sure that encryption index for a client matches what is in the encryption manager.

    Add the per-client encryption index cache. Clear it to -1 initially. Set it to the encryption index passed in on client connect.

    When the client connects, set the encryption index to that passed in.

TODO
    
    When receiving packets, look up the encryption index by address (common case) for connected clients.

    If the address exists in a connected client slot, use the encryption index from that slot.

    -----------------

    Implement send packets function for server so that it sends a keep alive packet to the client if no packet sent in the last amount of time.

    -----------------

    Add a 'confirmed' flag per-client slot on the server. Clear it to 0 when a client slot is connected.

    Extend the keep alive so it is sent repeatedly, even if other packets are sent from server -> client prior to confirm.

    -----------------

    Implement server-side timeouts.

    -----------------

    When the server receives a payload packet, add that to a queue for that client slot.

    -----------------

    Implement the code to send and receive payload packets.

    -----------------

    Extend client_server to test that client and server can exchange payload packets.

    -----------------

    Implement code on the server-side to disconnect the client.

    -----------------

    Once client and server are connected and have both exchanged payload packets, disconnect the client server-side.

    -----------------

    Implement replay protection.

    Support 1 second worth of replay protection @ 60HZ, eg. 60 packets per-client.

    Make sure global packets are ignored (eg. high bit set in sequence).

    -----------------










    =============================================================================

    Implement network simulator and shim for packets sent/received from client and server.

    -----------------

    Implement functional tests for client connect connection functionality.

    -----------------

    Bring across matcher in golang and port to binary format connect tokens.

    Integrate mbedtls library.

    Port across code for matcher. Keep it blocking. Doesn't matter for now.

    Convert client to get server info from web server.

    -----------------

    Implement stress that connects 256 clients.

    -----------------

    Write white paper.

    -----------------
