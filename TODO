DONE

    Implement the remaining packet types.

    Implement the payload packet. Include a data length in the packet, but don't serialize that to the buffer. 

    On read, reconstruct it from what is left in the packet.

    Done. Made the payload packet type a variable size struct. Seems like the best option.

    Added a maximum payload size of 1400 bytes. Seems reasonable given 1500 MTU. In future versions of the protocol, might be nice to let the server tell the client the maximum # payload packet size instead. 

    For a first pass, I think this is OK.

    Added a function to create the dynamically sized payload packet.

    Need to add a test for payload packet. Done.

    What's the most important thing to do next?

    On one hand I can setup a mocking structure (eg. transport) so I can test the client and server using a mocked socket layer.

    I mean really the thing needed for client/server to be mocked, would be to expose the function to process packets (manually call it instead of pumping from network), and provide a function pointer to call in order to send a packet to an address. This could then be hooked up to a simulator or a simple queue.

    In my experience, it's necessary to test the protocol under worst case conditions (packets out of order, jitter, latency, loss) to make sure a UDP-based protocol is working properly.

    So I think this isn't something that I can skip.

    But I don't want to expose this concept outside of the internal implementation. It's internal only, and compiles out in release build.

    Implement the client side of the state machine (simpler)

    Implement it all end-to-end. eg. the state machine, the packet processing, the sending packets etc.

TODO
    
    Making reasonable progress on the client state machine. Thinking of it more like a port job from C++ to C makes me hopeful that I can get this done quickly, as long as I don't make too many changes.

    -----------------

    Implement the server side of the state machine (up to 256 players, for agar.io)

    -----------------

    Implement tests to make sure the client/server state machine is working as expected.

    -----------------

    Bring across matcher in golang and port to binary format connect tokens.

    Integrate mbedtls library.

    -----------------

    Bring across a netcode_socket_t

    Implement just enough to get my shit done.

    Probably need more address functionality to interface with sockets sendto/recvfrom as well.

    -----------------

    Implement standalone server on localhost port 40000.

    -----------------

    Port across code for matcher. Keep it blocking. Doesn't matter for now.

    -----------------

    Implement client that connects to matcher, gets connect token and connects to server.

    Implement stress that connects 256 clients.

    -----------------

    Write white paper.

    -----------------
