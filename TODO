DONE

    Bring across encrypt/decrypt functions that wrap libsodium.

    Implement encrypt/decrypt connect token function.

    Adjusted them so read/write connect token and encrypt/decrypt are separate

    Add a unit test to encrypt and decrypt connect token (extend test_connect_token)

    Some minor adjustments to for loops so it works on linux.

    Add code to test libsodium version and fallback to non-overlapping buffer in this case.

    Verified both cases work.

    Extend code to read connection request packet to decrypt connect token in place.

    Will need to extend the connection request to pass in a real connect token and write it to buffer, then encrypt it.

    Need to formalize the version information, because this must become part of the additional data.

    Can't let a client lie about the version information to try to crash out a server with invalid data (from a different version).

TODO

    -----------------

    Bring across implementations for challenge token functions.

    -----------------

    Convert across code to generate a connect token, encrypt a connect token, decrypt a connect token.

    Add tests for generate, encrypt and decrypt connect tokens.

    -----------------

    Extend connection request packet read so that it decrypts the connect token.

    This allows for quick reject of connection packets before performing allocation.

    Extend the connection request packet test so that it creates an actual connect token, encrypts it, verifies it is decrypted properly on read.

    -----------------

    Add tests for all the cases that should return NULL on connection request packet

    1. packet too small

    2. timestamp expired

    3. invalid connect token data

    4. timestamp modified from original (eg. AEAD signature early out)

    (there are more conditions now, with the expanded AEAD...)

    -----------------

    Implement read write for one of the other packet types.

    This involves designing the prefix byte, sequence # compression and encrypted data.

    The reader should perform decryption in place, so no allocation is made for a packet that doesn't pass the test. Quick reject is key.

    Once one encrypted packet type is tested working, implement the rest, adding tests for each packet type to make sure they are read/written correctly.

    -----------------
