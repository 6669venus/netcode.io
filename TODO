DONE

    Added some error logs when the connect data fails to read. Will want to see these in the reference client for debug purposes.

    Later on going to want to add this 

    Would be nice if the connect data from the server included the timeout value for the client to use. This way it could be customizable server-side.

    Done.

    Add code to track time connect started, and if the connect goes on longer than the connect data expire time (expire timestamp - create timestamp), timout the connect to a new state "connect token expired".

    This avoids a bad situation where clients with lots of servers in their list keep trying to use the connect token to connect, which will be ignored by the server, therefore client will wait up to timeout (5 seconds) * number of servers left to try after timeout.

    Done.

    Port across code to parse a string to an address.

    Implement code to parse the array of addresses and generate a connect token given a private key.

    This will unblock further work on the client state machine, ideally I would be able to finish the client by end of day today, at minimum.

    Maybe connect data should be renamed "server info"?

    I dislike the similarity between "connect data" and "connect token".

    I like the name server info. It's describes the servers to connect to. It *contains* a connect token. Its distinct enough to avoid confusion.

    Renaming now. Completed. I think this is much better, especially when people "talk" about this protocol.

    A "server info" is very distinct in naming from "connect token". They would not be confused.

TODO

    ------------------

    Implement client connecting with a generated connect data.

    ------------------

    Add code to send the other packet types.

    ------------------

    Work out a design for the 

    ------------------

    Work out how packets will be sent to the server, and how this will be mocked for testing purposes (eg. through a loopback or simulator, without all the complexity of 'transport' concept).

    I'm thinking a callback function to perform the actual send which by default goes through a socket, but can be overridden to do something else (eg. simulator or pass directly to the server).

    -----------------

    Port across the code to process packets.

    -----------------

    Implement the server side of the state machine (up to 256 players, for agar.io)

    -----------------

    Implement tests to make sure the client/server state machine is working as expected.

    -----------------

    Bring across matcher in golang and port to binary format connect tokens.

    Integrate mbedtls library.

    -----------------

    Bring across a netcode_socket_t

    Implement just enough to get my shit done.

    Probably need more address functionality to interface with sockets sendto/recvfrom as well.

    -----------------

    Implement standalone server on localhost port 40000.

    -----------------

    Port across code for matcher. Keep it blocking. Doesn't matter for now.

    -----------------

    Implement client that connects to matcher, gets connect token and connects to server.

    Implement stress that connects 256 clients.

    -----------------

    Write white paper.

    -----------------
