DONE

    Integrate encryption manager into server

    Removed cut & paste code for the connect token entry clear. It's now a single function.

    Add an encryption mapping when a connection request is accepted.

    Add the code to call find or add connect token entry before accepting connect tokeng.

    Done. To get this to work I had to remove the code that cleared the connect token mac from the decrypted connect token data, because I need this mac for the connect token entries.

    Extend challenge token to include user data.

    Increased challenge token bytes to 360 so the 256 byte user data can fit.

    Update tests to insert random user data and check that it matches.

    Send connection challenge back to client when receiving a connection challenge.

    Client should transition to sending connection response state when receives connection challenge.

    Now I need to write code to look up the encryption mapping from address, so the server can receive the packets sent from pending clients.

    To do this, when a packet comes in, I need to look up given the "from" address what the encryption mapping would be, and then use that to find the correct private key to pass in.

    Theoretically, I can avoid this if I know the first byte of that packet is zero.

    This is probably a worthwhile optimization to make, but does it make the game any more secure?

    Avoiding the O(n) cost until after the packet is validated (eg. decrypted), is not possible, you need the key to know that.

    So the search for the key must be performed for any encrypted packet type received, so it would not be a valid optimization to make. An attacker would just send encrypted packet types instead of connection request packets.

    So don't implement the optimization, it's not worth it.

TODO

    Add code to get the packet receive key for the packet address, so encrypted packets can be read on the server.

    Verify that connection response packets are being received by the server.

    -----------------

    Port across code to process the connection response.

    -----------------

    Work out what the next state is for clients on connection response.

    Does the client get fully connected, with a pending flag, so the client keeps sending the keep-alive until connection is confirmed.

    Or do I extend the server-side to have a state per-slot, eg. 

        CLIENT_SLOT_FREE
        CLIENT_SLOT_PENDING
        CLIENT_SLOT_CONNECTED

    Think over this for a while, because any deviation from how yojimbo does it needs to have a good reason.

    -----------------

    Port across context manager above server.

    Add tests for context manager    

    -----------------

    Implement code to process connection response packet from client and complete connection.

    -----------------

    Work out what I need in the struct allocated per-client slot.

    -----------------

    Work out what arrays I need for fast O(n) lookups for incoming packets (keep them separate). Hot/cold split.

    -----------------

    Get client connecting to server.

    -----------------

    Implement network simulator and shim for packets sent/received from client and server.

    -----------------

    Implement replay protection.

    -----------------

    Implement functional tests for client connect connection functionality.

    -----------------

    Bring across matcher in golang and port to binary format connect tokens.

    Integrate mbedtls library.

    Port across code for matcher. Keep it blocking. Doesn't matter for now.

    Convert client to get server info from web server.

    -----------------

    Implement stress that connects 256 clients.

    -----------------

    Write white paper.

    -----------------
