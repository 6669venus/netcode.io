DONE

    When receiving packets, look up the encryption index by address (common case) for connected clients.

    If the address exists in a connected client slot, use the encryption index from that slot.

    Implement send packets function for server so that it sends a keep alive packet to the client if no packet was sent in the last amount of time.

    Added per-client sequence numbers, and a function to send client packets. Replaced the keepalive packet sends to be per-client, since they occur post client connection.

    For some reason, the server is sending just one keep alive packet and then stopping. Not sure why. Investigating...

    Just some bad logic, >= rather than <= on the timeout vs. time check.

    Add a 'confirmed' flag per-client slot on the server. Clear it to 0 when a client slot is connected.

    When the server receives a keep alive from the client, *or* a payload packet, set confirmed to 1, since the client will only transition to a state where it sends either of this when it receives a keep alive packet from the server.

    Implement server-side timeouts.

    Test server-side timeouts (loosely speaking...)

TODO

    Add code to clear the client slot when they are disconnected.
    
    Add code to send disconnect packets to client on server-side disconnect.

    -----------------

    When the server receives a payload packet, add that to a queue for that client slot.

    -----------------

    Implement the code to send and receive payload packets on the server.

    When the server sends a payload packet to a client, if that client is not confirmed yet, send a keep alive first, so a keep-alive packet always precedes payload until confirmation is in.

    This is the smartest way to reduce the connection round trips, and still get the common case being that the server can send payload packets immediately to client, without waiting for confirmation.

    This is good. Lock it in.

    -----------------

    Extend client_server to test that client and server can exchange payload packets.

    -----------------

    Implement code on the server-side to disconnect the client.

    -----------------

    Once client and server are connected and have both exchanged payload packets, disconnect the client server-side.

    -----------------

    Implement replay protection.

    Support 1 second worth of replay protection @ 60HZ, eg. 60 packets per-client.

    Make sure global packets are ignored (eg. high bit set in sequence).

    -----------------










    =============================================================================

    Implement network simulator and shim for packets sent/received from client and server.

    -----------------

    Implement functional tests for client connect connection functionality.

    -----------------

    Bring across matcher in golang and port to binary format connect tokens.

    Integrate mbedtls library.

    Port across code for matcher. Keep it blocking. Doesn't matter for now.

    Convert client to get server info from web server.

    -----------------

    Implement stress that connects 256 clients.

    -----------------

    Write white paper.

    -----------------
