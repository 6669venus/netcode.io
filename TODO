DONE

    Implement the remaining packet types.

    Implement the payload packet. Include a data length in the packet, but don't serialize that to the buffer. 

    On read, reconstruct it from what is left in the packet.

    Done. Made the payload packet type a variable size struct. Seems like the best option.

    Added a maximum payload size of 1400 bytes. Seems reasonable given 1500 MTU. In future versions of the protocol, might be nice to let the server tell the client the maximum # payload packet size instead. 

    For a first pass, I think this is OK.

    Added a function to create the dynamically sized payload packet.

    Need to add a test for payload packet. Done.

    What's the most important thing to do next?

    On one hand I can setup a mocking structure (eg. transport) so I can test the client and server using a mocked socket layer.

    I mean really the thing needed for client/server to be mocked, would be to expose the function to process packets (manually call it instead of pumping from network), and provide a function pointer to call in order to send a packet to an address. This could then be hooked up to a simulator or a simple queue.

    In my experience, it's necessary to test the protocol under worst case conditions (packets out of order, jitter, latency, loss) to make sure a UDP-based protocol is working properly.

    So I think this isn't something that I can skip.

    But I don't want to expose this concept outside of the internal implementation. It's internal only, and compiles out in release build.

    Implement the client side of the state machine (simpler)

    Implement it all end-to-end. eg. the state machine, the packet processing, the sending packets etc.

    Making reasonable progress on the client state machine. Thinking of it more like a port job from C++ to C makes me hopeful that I can get this done quickly, as long as I don't make too many changes.

    Port across more bits of the C++ code, and see how it fits. I should be able to port over most of the state machine structure, with commented out parts.

TODO

    Biggest things that need to be done for client:

        0. actually generate and send "connection request packets" to the server, while in the connection request state

        1. work out how packets will be sent to the server, and how this will be mocked for testing purposes (eg. through a loopback or simulator, without all the complexity of 'transport' concept)

        2. port across the code to process packets and comment most bits out

        3. get the actual connect working from real data (eg. a connect token + associated data... big sink hole here)

    I feel that the client is starting to get complex, although this is a reference implementation it needs to be:

        a) testable

        b) readable

    This is not write only code.

    Make sure the code that is written is as simple as possible, and readable. It's starting to jump around a bit with the literal porting from C++. Think if this can be simplified in some way.

    -----------------

    Specifically, the setting client state in one place is important for logging so do that. I need this printed out.

    -----------------

    Implement the server side of the state machine (up to 256 players, for agar.io)

    -----------------

    Implement tests to make sure the client/server state machine is working as expected.

    -----------------

    Bring across matcher in golang and port to binary format connect tokens.

    Integrate mbedtls library.

    -----------------

    Bring across a netcode_socket_t

    Implement just enough to get my shit done.

    Probably need more address functionality to interface with sockets sendto/recvfrom as well.

    -----------------

    Implement standalone server on localhost port 40000.

    -----------------

    Port across code for matcher. Keep it blocking. Doesn't matter for now.

    -----------------

    Implement client that connects to matcher, gets connect token and connects to server.

    Implement stress that connects 256 clients.

    -----------------

    Write white paper.

    -----------------
