DONE

    Sketched out packets.

    Sketched out basic interface for reading and writing packets.

    This is going to work out pretty well.

    Extend code to take pointer to pointer for write bytes, so pointer can be advanced as writing is done.

    Implement helper functions to write uint8, uint16, uint32, uint64, bytes.

    Implement helper functions to read uint8, uint16 etc.

    Implement packet read function for connection request packet.

    Write a test that verifies that we can write a connection request packet and then read it back in.

    Alternatively, skip JSON and make the connect token a binary format.

    It's not a huge problem to generate this binary from web languages, and it's much more efficient.

    I like this idea. Fuck JSON.

    Fixed code that reads and writes the connection request packet. It was incorrect. Not sure how it was passing tests on MacOSX?

    Sketching out utility functions related to connect token, challenge token.

TODO

    Need to bring across implementations for connect token, challenge token functions.

    These are binary not JSON, so hopefully I can avoid bringing in a JSON parser for the reference code.

    However, the connect token and challenge token should probably have a "type" in the value written to memory (spec), so different AEAD implementations can be used. Default AEAD_LIBSODIUM_CHACHAPOLY1234134 whatever it is.

    This will affect the packets sent. Connection request, challenge and response packets should be encoded to support the concept of "type", which will allow future expansion to different AEAD constructions.

    Thinking of this, it's probably appropriate (necessary) to support variable length tokens. Have a maximum length. Set it at 1400 below conservative MTU, but let it be less, depending on type. Still want to pad up the type to the 1400.

    -----------------

    Convert across code to generate a connect token, encrypt a connect token, decrypt a connect token.

    Add tests for generate, encrypt and decrypt connect tokens.

    -----------------

    Extend connection request packet read so that it decrypts the connect token.

    This allows for quick reject of connection packets before performing allocation.

    Extend the connection request packet test so that it creates an actual connect token, encrypts it, verifies it is decrypted properly on read.

    -----------------

    Add tests for all the cases that should return NULL on connection request packet

    1. packet too small

    2. timestamp expired

    3. invalid connect token data

    4. timestamp modified from original (eg. AEAD signature early out)

    -----------------

    Implement read write for one of the other packet types.

    This involves designing the prefix byte, sequence # compression and encrypted data.

    The reader should perform decryption in place, so no allocation is made for a packet that doesn't pass the test. Quick reject is key.

    Once one encrypted packet type is tested working, implement the rest, adding tests for each packet type to make sure they are read/written correctly.

    -----------------
