DONE

    Add the data structure for the per-client payload packet queue. 

    Stick it last in the netcode_server_t.

    When the server receives a payload packet, add that to a queue for that client slot.

    When the server stops, pop all packets off each client packet queue and free them.

    Do the same for the client. It's probably not doing this!

    Yes. It wasn't.

    Implement the code to send and receive payload packets on the server.

    Base this on the code from the client.

    When the server sends a payload packet to a client, if that client is not confirmed yet, send a keep alive first, so a keep-alive packet always precedes payload until confirmation is in.

    This is the smartest way to reduce the connection round trips, and still get the common case being that the server can send payload packets immediately to client, without waiting for confirmation.

    This is good. Lock it in.

    Extend client_server to test that client and server can exchange payload packets.

    First step I notice that after a while client seems be sending both keepalive packets and payload packets. 

    Instead, it should stop sending keepalives once payloads are sent. Debugging...

    Fixed by updating send rate to 60HZ. My guess is that with framerate @ 10HZ, and keep alive at 10HZ, it's too close for comfort (eg. off by one frame)

    Now need a function to check if client is connected on server.

    Done. Now payload packets sent in both directions.

    Logs show that the server is sending both payload packets and keep alives to client.

    Should only send payloads, not keep alive once confirmed.

    Fixed. Inverted logic.

TODO

    -----------------

    Once client and server are connected and have both exchanged payload packets, disconnect the client server-side.

    Then wait until both client and server are fully disconnected before quitting.

    -----------------

    Extend separate client/server to exchange payload packets.

    -----------------

    Implement stress test that connects 256 clients and exchanges payload packets.

    -----------------

    Implement replay protection.

    Support 1 second worth of replay protection @ 60HZ, eg. 60 packets per-client.

    Make sure global packets are ignored (eg. high bit set in sequence).

    -----------------










    =============================================================================

    Implement network simulator and shim for packets sent/received from client and server.

    -----------------

    Implement functional tests for client connect connection functionality.

    -----------------

    Bring across matcher in golang and port to binary format connect tokens.

    Integrate mbedtls library.

    Port across code for matcher. Keep it blocking. Doesn't matter for now.

    Convert client to get server info from web server.

    -----------------

    Write white paper.

    -----------------
